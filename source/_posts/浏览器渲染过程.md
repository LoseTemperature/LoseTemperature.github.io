---
title: 浏览器渲染过程
date: 2025-01-11
tags: [浏览器, 程序员, 技术]
categories: [技术分享]
---
## 1. 通信部分
  1. URL解析与检查缓存
  - 浏览器会对你输入的URL（统一资源定位符）进行解析，确定请求的协议（如 HTTP/HTTPS）、域名、端口号、路径等信息
  - 浏览器缓存检查： 浏览器会检查自身的 缓存（包括强缓存和协商缓存）如果有相应的未过期资源，浏览器会直接从本地加载，大幅加快速度
  2. DNS域名解析
  - 浏览器需要知道域名对应的 IP 地址 才能进行通信 ，如果想要的资源不在缓存中，此时触发DNS（从浏览器缓存开始，然后依次查询操作系统的 hosts、本地 DNS ，直到 根域名服务器、顶级域名服务器、权限域名服务器，最终获取到目标服务器的 IP 地址）
  3. 建立TCP
  - http三次握手 
  ![alt text](/images/tcp1.png)
  - https 在http握手的基础上在应用层上增加TLS/ssl(已废弃)握手，用来加密通道与身份验证，保证数据安全
  4. 浏览器发送 HTTP 请求
  - TCP联接建立后，浏览器向服务器发送http请求报文 报文包含：请求行（如 GET /index.html HTTP/1.1）、请求头（包含 Host、User-Agent、Cookie、Accept-Encoding 等信息）、以及可选的 请求体
  5. 服务器处理请求与返回 HTTP 响应
  - 服务器收到请求进行处理（查询数据库、运行后台程序等）
  - 处理完成后服务器构建响应报文（状态行（如 HTTP/1.1 200 OK）、响应头（包含 Content-Type、Content-Length、Set-Cookie 等信息）和 响应体（通常是请求的 HTML 文档 内容））给浏览器
  6. 断开TCP链接
  ![alt text](/images/tcp2.png)

  ### http 与tcp udp补充
  - http1.1基于tcp 分为短连接和长连接，短连接每次发送都要重新建立一次连接 ，长连接为连接一次传多个数据包，但数据包是顺序的单行通路，其中有一个包出问题所有包全部阻塞
  - http2基于tcp 逻辑上是多路复用，但到tcp实现依旧是单行道，所以还会出现 队头阻塞
  - http3使用QUIC（基于udp）逻辑上是多通道，实际有一个通路出现问题，只会暂停出问题的通道不会全线阻塞，并且连接速度比TCP快很多，
  QUIC实质上就是在udp的快速连接传输的基础上实现了快速可靠的传输。

  ## 2. 页面渲染部分（浏览器接收到服务器传来的html文档并下载解析）
  7. 渲染树构建
  - 首先会解析HTML并构建DOM树
  - 再解析并构建CSSOM树
  - 将DOM和CSSOM树合并构成Render Tree（他不会包含所有的DOM和CSSOM内容，通过计算会留下要展示和计算过的样式和结构）
  8. 布局（Layout）   （重排 reflow ，也是发生在这个时候）
  - 浏览器会根据渲染树的结构，计算出所有可见元素在屏幕上的确切位置和大小
  9. 绘制（painting）  （重绘 repaint ，发生在这个时候）
  - 布局完成后浏览器会调用图形 API 将渲染树中的每个元素绘制到屏幕上，包括绘制文本、颜色、边框、阴影、图片等
  10. 执行js （当解析html过程中 遇到js）
  - 浏览器会 暂停 HTML 解析，转而下载并执行 JavaScript 代码
  - JavaScript 可能会操作 DOM 树和 CSSOM 树，这可能导致浏览器需要重新进行 布局 (Reflow) 和 绘制 (Repaint)，从而修改页面的结构或外观
  11. 当所有的资源（HTML、CSS、图片等）都被下载、解析、渲染完毕，并且所有脚本都执行完成后，页面即被视为 加载完毕。浏览器会在此时触发 load 事件

  ### 渲染优化补充
  在实际上有三个时间点需要关注，因为他们会引起阻塞
  1. CSS 阻塞后续渲染： 浏览器必须等待 CSSOM 准备好，才能创建渲染树 
  - 优化手段： 关键 CSS 内联。把首屏样式直接放在 <style> 中，减少外部文件延迟，非关键 CSS 可以使用 <link rel="preload" as="style" onload="..."> 异步加载
  2. JavaScript 阻塞 (JS 阻塞 DOM 构建和渲染)
  - ![alt text](/images/jsZuSe.png)
  - 这里也可以分割js加载优先级高的js部分，其他部分延迟加载
  3. **首页显示与交互阻塞** （首次绘制（FCP）也就是白屏时间问题，可交互时间（TTI）也就是首页加载了但功能还不能用问题）
  实际上我们可以通过SSR（服务端渲染），注水 (Hydration)来优化FCP与TTI
    * 首先，我们的项目最终是跑在服务器上的，本地加载需要向服务器来请求并下载真实的html，css,js本地，浏览器再去解析这些东西得到最终展示的文档并展示出来，那么我们要知道的是，本地（客户端）的计算能力是要弱于实际上的服务端的，那SSR实质上就是在服务端运行框架的js内容生成对应的HTML（主要是那些js创建的DOM结构会阻塞html渲染，所以这里解决的主要也是js创建的DOM，css也仍然阻塞）字符串，把这个开箱就能用的文档发给客户端就可以快速的展示出实际页面了（由于服务端运算快，也不用等待JS下载执行） 
    * 然后浏览器开始注水，浏览器下载并执行对应的JS代码（这里就是事件相关的东西了） ，把相应到事件绑定有DOM上，并监听，然后用户就可以交互了