---
title: 权限管理与路由
date: 2025-01-11
tags: [浏览器, 程序员, 技术]
categories: [技术分享]
---

# 权限管理
- 当下的权限管理主流思想是RBAC (Role-Based Access Control)，即基于角色的访问控制。它的核心思想是，不直接给用户分配权限，而是在用户和权限之间引入一个**角色**（Role）层

1. 用户 (User): 就是你的系统使用者，比如张三、李四。

2. 角色 (Role): 系统中的身份，比如“管理员 (Admin)”、“普通编辑 (Editor)”、“访客 (Guest)”。一个用户可以拥有一个或多个角色。

3. 权限 (Permission): 对系统资源的操作许可。这个要尽可能原子化。比如：
* 查看用户列表 (user:list)
* 新增用户 (user:add)
* 编辑文章 (article:edit)
* 访问Dashboard页面 (page:dashboard)

- 通过这种方式，当需要给一类用户授权时，我们只需要修改这个角色所拥有的权限，所有属于该角色的用户的权限就都更新了。这极大地简化了权限管理，避免了对每个用户进行单独授权的复杂操作。

## 前端权限管理

### 前端权限管理层次划分

- 路由权限：用户是否能通过 URL 直接访问某个页面
- 菜单权限：用户登录后，左侧的导航菜单应该只显示他有权限访问的项
- 操作权限：同一个页面中，不同角色的用户能看到和操作的按钮或元素是不同的。例如，管理员能看到“删除用户”按钮，而普通编辑则看不到，当然也还有一些数据源，比如用户列表，普通编辑和访客用户只能看到部分数据，管理员能看到所有数据。

* 这其中路由权限是核心，菜单权限和操作权限都是在路由权限的基础上衍生出来的

### 静态路由权限控制 
- 前端将系统中所有的路由规则全部定义好，包括那些需要权限才能访问的页面。每个路由规则通过一个 meta 字段来标记访问该路由所需要的角色或权限。当用户登录后，根据用户的角色信息，动态计算出他可以访问的路由，并生成对应的菜单。

1. 在你的路由配置文件中 (e.g., router/index.js)，定义好所有的路由，并用 meta 标记权限
```js
// router/index.js
const routes = [
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/Login.vue'),
    meta: { title: '登录', requiresAuth: false } // 不需要权限
  },
  {
    path: '/',
    component: Layout,
    redirect: '/dashboard',
    children: [{
      path: 'dashboard',
      name: 'Dashboard',
      component: () => import('@/views/Dashboard.vue'),
      meta: { title: '仪表盘', roles: ['admin', 'editor'] } // admin 或 editor 才能访问
    }]
  },
  {
    path: '/user-management',
    component: Layout,
    children: [{
      path: '',
      name: 'UserManagement',
      component: () => import('@/views/UserManagement.vue'),
      meta: { title: '用户管理', roles: ['admin'] } // 只有 admin 才能访问
    }]
  },
  {
    path: '/403',
    name: 'Forbidden',
    component: () => import('@/views/error/403.vue'),
  },
  {
    path: '/:pathMatch(.*)*', // 捕获所有未匹配的路由
    name: 'NotFound',
    component: () => import('@/views/error/404.vue'),
  }
];
```
2. 设置全局路由守卫（router.beforeEach）
```js
// main.js or router/index.js
import router from './router';
import store from './store'; // 假设用 Vuex/Pinia 管理用户状态

router.beforeEach(async (to, from, next) => {
  const token = getToken(); // 从 cookie 或 localStorage 获取 token

  if (token) {
    if (to.path === '/login') {
      // 如果已登录，还想去登录页，则重定向到首页
      next({ path: '/' });
    } else {
      // 检查用户角色是否已获取
      const userRoles = store.getters.roles;
      if (userRoles && userRoles.length > 0) {
        // 已有角色信息，直接放行
        checkPermissions(to, userRoles, next);
      } else {
        try {
          // 异步获取用户信息（包含角色）
          const { roles } = await store.dispatch('user/getInfo');

          // 再次检查权限
          checkPermissions(to, roles, next);
        } catch (error) {
          // 获取用户信息失败（例如 token 失效）
          await store.dispatch('user/logout'); // 清除 token 和用户信息
          next(`/login?redirect=${to.path}`); // 重定向到登录页
        }
      }
    }
  } else {
    // 未登录
    if (to.meta.requiresAuth === false) {
       next(); // 如果是不需要权限的页面，直接放行
    } else {
      // 否则重定向到登录页
      next(`/login?redirect=${to.path}`);
    }
  }
});

function checkPermissions(to, userRoles, next) {
  if (to.meta.roles) {
    // 检查用户角色是否至少有一个在路由要求的角色列表中
    const hasPermission = userRoles.some(role => to.meta.roles.includes(role));
    if (hasPermission) {
      next(); // 有权限，放行
    } else {
      next('/403'); // 无权限，跳转到 403 页面
    }
  } else {
    // 如果路由没有 meta.roles 字段，表示这是一个公开页面，直接放行
    next();
  }
}
```
3. 生成菜单
登录并获取到用户角色后，遍历完整的路由表，根据用户的角色筛选出他有权访问的路由，然后用这个筛选后的路由列表来渲染侧边栏菜单

优点：
* 实现相对简单，逻辑清晰;所有路由配置都在前端，一目了然
-----
缺点：
* 安全性较低：所有的页面组件和路由信息都打包在前端代码里，即使用户无法访问，也可以通过分析代码包看到系统的所有页面结构
* 灵活性差: 如果要新增一个角色或者修改某个页面的权限，除了后端修改，前端也必须修改代码并重新部署

### 动态路由权限控制
- 前端只定义一些基础的、不需要权限的路由（如登录页、404页）。用户登录成功后，向后端请求该用户有权访问的路由列表。前端拿到这个列表后，动态地将其添加到 Vue Router 实例中
1. 分离路由配置:
将路由分为两部分：
  - constantRoutes (常量路由): 所有人都能访问的页面，如 login, 404, home 等。
  - asyncRoutes (异步路由): 需要根据权限动态添加的页面路由
```js
// router/index.js

// 常量路由
export const constantRoutes = [
  { path: '/login', component: () => import('@/views/Login.vue') },
  { path: '/404', component: () => import('@/views/error/404.vue') }
];

// 异步路由（完整的路由表）
export const asyncRoutes = [
  {
    path: '/',
    component: Layout,
    redirect: '/dashboard',
    children: [{
      path: 'dashboard',
      name: 'Dashboard',
      component: () => import('@/views/Dashboard.vue'),
      meta: { title: '仪表盘', icon: 'dashboard' }
    }]
  },
  {
    path: '/user-management',
    component: Layout,
    name: 'UserManagement',
    meta: { title: '用户管理', icon: 'user' },
    children: [
        { path: 'list', name: 'UserList', component: () => import('@/views/user/List.vue'), meta: { title: '用户列表' } },
        // ...
    ]
  },
  // IMPORTANT: Not Found 路由必须最后添加
  { path: '/:pathMatch(.*)*', redirect: '/404', hidden: true }
];

const createRouter = () => new VueRouter({
  routes: constantRoutes // 初始只加载常量路由
});

const router = createRouter();

export default router;
```
2. 登录后获取并生成可访问路由
```js
// store/modules/permission.js
import { asyncRoutes, constantRoutes } from '@/router';

// 后端返回的路由数据可能是这样的：['Dashboard', 'UserManagement']
function filterAsyncRoutes(routes, userAccessRoutes) {
  const res = [];
  routes.forEach(route => {
    const tmp = { ...route };
    // 如果用户的权限路由列表里包含了当前路由的 name
    if (userAccessRoutes.includes(tmp.name)) {
      if (tmp.children) {
        // 递归过滤子路由
        tmp.children = filterAsyncRoutes(tmp.children, userAccessRoutes);
      }
      res.push(tmp);
    }
  });
  return res;
}

const state = {
  routes: [],
  addRoutes: []
};

const mutations = {
  SET_ROUTES: (state, routes) => {
    state.addRoutes = routes;
    state.routes = constantRoutes.concat(routes); // 完整路由表
  }
};

const actions = {
  generateRoutes({ commit }, userAccessRoutes) {
    return new Promise(resolve => {
      let accessedRoutes;
      // 假设后端返回的是一个路由 name 的数组
      accessedRoutes = filterAsyncRoutes(asyncRoutes, userAccessRoutes);
      commit('SET_ROUTES', accessedRoutes);
      resolve(accessedRoutes);
    });
  }
};
```
3. 在导航守卫中动态添加路由
```js
// main.js or router/permission.js
import router from './router';
import store from './store';

router.beforeEach(async (to, from, next) => {
  const token = getToken();

  if (token) {
    if (to.path === '/login') {
      next({ path: '/' });
    } else {
      const hasRoutes = store.getters.permission_routes && store.getters.permission_routes.length > 0;
      if (hasRoutes) {
        next(); // 如果已经添加过路由，直接放行
      } else {
        try {
          // 1. 获取用户信息，其中包含权限标识（例如后端返回的路由name数组）
          const { accessRoutes } = await store.dispatch('user/getInfo');

          // 2. 根据权限标识，生成可访问的路由表
          const accessedRoutes = await store.dispatch('permission/generateRoutes', accessRoutes);

          // 3. 动态添加路由到 Router 实例
          // 使用 router.addRoute() 逐个添加
          accessedRoutes.forEach(route => {
            router.addRoute(route);
          });

          // Hack: 确保 addRoute() 完成后，再进行跳转
          // replace: true 这样导航就不会留下历史记录
          next({ ...to, replace: true });
        } catch (error) {
          await store.dispatch('user/logout');
          next(`/login?redirect=${to.path}`);
        }
      }
    }
  } else {
    // ... 未登录逻辑同上 ...
  }
});
```
4. 生成菜单
菜单的数据源直接就是 store 中存储的那份已过滤好的、可访问的路由列表 (permission_routes)
优点：
* 安全性高: 前端代码包中不包含完整的路由信息，用户无法窥探整个系统的页面结构
* 非常灵活: 权限完全由后端控制。修改权限、增删页面，前端无需任何改动和重新部署
-----
缺点：
* 实现逻辑相对复杂，需要前后端约定好路由数据结构

### 其他细节

