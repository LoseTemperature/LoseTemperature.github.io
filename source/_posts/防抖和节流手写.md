---
title: 防抖和节流手写
date: 2025-01-11
tags: [浏览器, 程序员, 技术]
categories: [技术分享]
---

# 💡 手写防抖（debounce）与节流（throttle）

> 本文是我在实现防抖与节流过程中逐行梳理逻辑、验证机制、理解底层行为的记录。
> 不是直接给结论，而是希望“每一行为什么这么写”都能说得通。

---

## 🧱 手写防抖（debounce）

### 1️⃣ 目标
实现一个支持以下特性的防抖函数：
- 可配置 `wait` 时间；
- 支持 `leading`（是否首部执行）；
- 支持 `trailing`（是否尾部执行）；
- 带有 `flush` 与 `cancel` 方法。

---

### 2️⃣ 核心代码 + 全注释

```js
// 手写 防抖

// 设置 wait 默认值 以及配置项 leading 是否首部执行, trailing 是否尾部执行
// trailing ：在你触发事件后，debounce 会有一个 wait 时间后再触发传入的回调。
// 那 trailing 实际是规定在 wait 时间内再次触发事件会不会刷新 wait 时间。
// 如果为 false 那在 wait 中触发的事件不会计入 wait 的等待时间，也就是回调依然会在首次 wait 时间过后执行，
// 而不是按最后一次执行后开始 wait 时间（或者说 wait 时间内再次触发不会让 wait 延时）

function debounce(func, wait = 300, options = {}) {
  let timer = null // 定时器闭包变量，保留定时器ID
  let result = null // 返回值 
  let lastArgs = null   // 保存最近一次调用时的参数和 this
  let lastThis = null;

  const { leading = false, trailing = true } = options // 配置解构

  // 回调辅助函数 
  const invokeFunc = () => {
    result = func.apply(lastThis, lastArgs) // 用保留的最近的 this 和参数去执行回调（在合适的时机执行）并把结果储存
    lastThis = lastArgs = null // 保存状态置 null 
  }

  // 启动计时器
  const startTimer = () => {
    timer = setTimeout(() => {
      timer = null // 后面通过 timer 是否为 null 判断我们是否处在“冷却期”。leading 的判断（是否立即执行）依赖这个信息。
      // 调用回调
      if (trailing && lastArgs) invokeFunc() // 是否尾部执行
    }, wait)
  }

  // debounce 核心
  const debounced = function (...args) { // ...args 是 ES6 对 arguments 的新语法，是一个用来获取 event 的真数组
    lastArgs = args
    lastThis = this

    const shouldCallNow = leading && !timer // 是否首部执行

    clearTimeout(timer)
    startTimer()

    if (shouldCallNow) invokeFunc()

    return result
  }

  // flush 方法：是否立即执行挂起的尾部调用
  debounced.flush = function () {
    if (timer) {
      clearTimeout(timer)
      timer = null
      if (lastArgs) invokeFunc()
    }
  }

  // cancel 方法：是否取消当前挂起的回调
  debounced.cancel = function () {
    if (timer) clearTimeout(timer)
    timer = lastArgs = lastThis = null
  }

  return debounced // 返回配置好的新函数，也就是高级函数封装好的，按照需求封装好配置项的，真正接收实际功能的函数
}
3️⃣ 实现思路总结
用闭包保存当前计时器 ID；

每次触发都清空旧计时器；

leading 控制是否立即执行；

trailing 控制尾部是否执行；

附带 flush() 与 cancel() 让调用更灵活。

🧭 手写节流（throttle）
1️⃣ 理解
节流与防抖的区别：

防抖是「等稳定再执行」，
节流是「定时触发」。

也就是防抖关注“最后一次”，节流关注“时间间隔”。

2️⃣ 核心代码 + 全注释
js
复制代码
// 手写 throttle
/**
 * @param {Function} func - 原函数
 * @param {number} wait - 时间间隔 (毫秒)
 * @param {Object} options - 配置项
 *    options.leading   是否在第一次触发时立即执行
 *    options.trailing  是否在停止触发后再执行一次
 */

function throttle(func, wait, options = {}) {

  let timer = null;
  let lastTime = 0;
  let lastArgs, lastThis, result;

  // 在比较时 undefined 不会默认转成 boolean，所以如果没有参数传入：
  // 默认为 undefined !== false (原始类型不同所以为 true)
  // 如果传入 false，则 false !== false 结果仍为 false
  // 逻辑上等同于 const leading = options.leading === undefined ? true : options.leading;
  const leading = options.leading !== false;   // 默认 true
  const trailing = options.trailing !== false; // 默认 true

  // 回调辅助函数
  const invokeFunc = (time) => {
    result = func.apply(lastThis, lastArgs);
    lastTime = time;
    lastArgs = lastThis = null;
  };

  // 计时启动辅助函数
  const startTimer = (remaining) => {
    timer = setTimeout(() => {
      const now = Date.now()
      if (trailing && lastArgs) {
        invokeFunc(now)
      }
      timer = null
    }, remaining)
  }

  // 核心函数
  const throttled = function (...args) {
    const now = Date.now()

    // ***leading 控制核心***
    if (!lastTime && !leading) lastTime = now // 如果 lastTime 为 0 并且 leading 为 false，则 lastTime 为当前时间

    const remaining = wait - (now - lastTime)

    lastArgs = args;
    lastThis = this;

    // 如果间隔时间到达，执行 func
    if (remaining <= 0 || remaining > wait) { // now - lastTime 可能是负数
      if (timer) {
        clearTimeout(timer)
        timer = null
      }
      invokeFunc(now)
    } else if (!timer && trailing) { // 否则在 trailing 情况下，启动定时器
      startTimer(remaining)
    }

    return result
  }

  // cancel 方法
  throttled.cancel = function () {
    clearTimeout(timer);
    timer = null;
    lastArgs = lastThis = null;
    lastTime = 0;
  };

  return throttled
}
3️⃣ 实现要点
lastTime 记录上次触发时间；

通过 (now - lastTime) 判断是否超出间隔；

leading 控制首部是否立即执行；

trailing 控制尾部是否再执行一次；

定时器 timer 用于处理尾部执行；

提供 .cancel() 清除状态。

🧩 防抖 vs 节流 对比表
对比项	防抖 (Debounce)	节流 (Throttle)
执行时机	一段时间后执行（停止触发）	固定时间间隔内最多执行一次
应用场景	输入框搜索、resize	scroll 滚动、拖拽、频繁点击
控制手段	清除旧定时器	时间冷却机制
是否支持首尾执行	✅ 支持	✅ 支持
是否可取消	✅ 支持	✅ 支持

🧠 一句话记忆
防抖：我等你不动了再说。
节流：我一分钟只说一次。

🧪 测试样例
js
复制代码
// 输入框防抖
const onInput = debounce(() => console.log('搜索请求发出'), 500, { leading: false, trailing: true });

// 滚动节流
window.addEventListener('scroll', throttle(() => console.log('滚动中...'), 200));
✅ 总结
防抖更适合延迟类任务；

节流更适合频率控制；

二者都依赖闭包保存状态；

掌握原理后可以灵活封装业务场景（如输入框、请求防抖、按钮点击节流等）。

写到这里，其实能真正手写出这两者逻辑的同学，
对「闭包」「执行上下文」「this绑定」「定时器机制」这些底层原理，基本都已经通透了。